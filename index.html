<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <title>Masked Input tests</title>
    <meta name="timeout" content="long" />
    <meta name="color-scheme" content="dark light" />
    <!-- polyfill for safari -->
    <script src="assets/polyfill/custom-elements.js"></script>
    <!-- Web Platform Tests (WPT) testing suite -->
    <script src="assets/wpt/testharness.js"></script>
    <script src="assets/wpt/testharnessreport.js"></script>
    <script src="assets/masked-input.js"></script>
    <style>
      :invalid {
        background-color: red;
      }
      :out-of-range {
        outline: 0.5em solid green;
        outline-offset: 1em;
      }
    </style>
  </head>
  <body>
    <input
      id="Pwd"
      type="password"
      is="masked-input"
      mask-pattern="___ ___ ___"
    />
    <input
      id="Nmbr"
      type="number"
      is="masked-input"
      mask-pattern="___ ___ ___"
      max="10"
      value="11"
    />
    <script>
      function createMaskedInput({ props = {}, attrs = {} }) {
        const maskedInput = document.createElement("input", {
          is: "masked-input",
        });

        for (const [attrName, attrValue] of Object.entries(attrs)) {
          maskedInput.setAttribute(attrName, attrValue ?? "");
        }
        for (const [propName, propValue] of Object.entries(props)) {
          if (propValue != null) {
            maskedInput[propName] = propValue;
          }
        }

        document.body.appendChild(maskedInput);

        return maskedInput;
      }
      function catchWindowError(callback) {
        let error;
        const listener = (event) => {
          event.preventDefault();
          error = event.error;
        };
        window.addEventListener("error", listener);
        try {
          callback();
        } finally {
          window.removeEventListener("error", listener);
        }
        return error;
      }
      function waitOneTick() {
        return new Promise((resolve) => {
          setTimeout(resolve, 0);
        });
      }

      const testCases = [
        {
          inputTypes: [
            "deleteContent",
            "deleteContentBackward",
            "deleteByDrag",
            "deleteByCut",
          ],
          baseInput: {
            maskPattern: "-_-_-_-",
            value: "1234",
            selectionStart: 0,
            selectionEnd: 0,
          },
          variants: [
            {
              description: "noop: delete backward when caret is at beginning",
              input: {},
              output: {
                value: "1234",
                maskedValue: "1234",
                passwordMaskedValue: "••••",
                selectionStart: 0,
                selectionEnd: 0,
              },
            },
            {
              description: "UNMASKED -> MASKED: delete backward from end",
              input: {
                selectionStart: 4,
                selectionEnd: 4,
              },
              output: {
                value: "123",
                maskedValue: "-1-2-3-",
                passwordMaskedValue: "-•-•-•-",
                selectionStart: 6,
                selectionEnd: 6,
              },
            },
            {
              description: "UNMASKED -> UNMASKED: delete backward from middle",
              input: {
                value: "12345",
                selectionStart: 4,
                selectionEnd: 4,
              },
              output: {
                value: "1235",
                maskedValue: "1235",
                passwordMaskedValue: "••••",
                selectionStart: 3,
                selectionEnd: 3,
              },
            },
            {
              description: "MASKED -> MASKED: delete backward from end",
              input: {
                value: "123",
                selectionStart: 4,
                selectionEnd: 4,
              },
              output: {
                value: "13",
                maskedValue: "-1-3- -",
                passwordMaskedValue: "-•-•- -",
                selectionStart: 3,
                selectionEnd: 3,
              },
            },
            {
              description:
                "UNMASKED -> MASKED: delete backward from end, showing replacement characters",
              input: {
                value: "123",
                selectionStart: 4,
                selectionEnd: 4,
                attributes: {
                  "show-replacement-characters": true,
                },
              },
              output: {
                value: "13",
                maskedValue: "-1-3-_-",
                passwordMaskedValue: "-•-•-_-",
                selectionStart: 3,
                selectionEnd: 3,
              },
            },
            {
              description:
                "MASKED -> UNMASKED: delete backward from end, going from single character to empty value",
              input: {
                value: "1",
                selectionStart: 2,
                selectionEnd: 2,
              },
              output: {
                value: "",
                maskedValue: "",
                passwordMaskedValue: "",
                selectionStart: 0,
                selectionEnd: 0,
              },
            },
            {
              description:
                "delete selection ([-1-2-3-]), going from masked to unmasked empty value",
              input: {
                value: "123",
                selectionStart: 0,
                selectionEnd: 6,
              },
              output: {
                value: "",
                maskedValue: "",
                passwordMaskedValue: "",
                selectionStart: 0,
                selectionEnd: 0,
              },
            },
            {
              description:
                "delete selection (-1[-2-3-]), going from masked to masked",
              input: {
                value: "123",
                selectionStart: 2,
                selectionEnd: 6,
              },
              output: {
                value: "1",
                maskedValue: "-1- - -",
                passwordMaskedValue: "-•- - -",
                selectionStart: 3,
                selectionEnd: 3,
              },
            },
            {
              description:
                "delete selection (-1-[2-3-]), going from masked to masked",
              input: {
                value: "123",
                selectionStart: 3,
                selectionEnd: 6,
              },
              output: {
                value: "1",
                maskedValue: "-1- - -",
                passwordMaskedValue: "-•- - -",
                selectionStart: 3,
                selectionEnd: 3,
              },
            },
            {
              description:
                "delete backward from end, going from masked single character to masked empty value",
              input: {
                value: "1",
                selectionStart: 2,
                selectionEnd: 2,
                attributes: {
                  "show-empty-mask": "true",
                },
              },
              output: {
                value: "",
                maskedValue: "- - - -",
                passwordMaskedValue: "- - - -",
                selectionStart: 1,
                selectionEnd: 1,
              },
            },
            {
              description: "delete grapheme cluster",
              input: {
                value: "🇯🇵🇺🇸",
                maskPattern: "-__-",
                selectionStart: 5,
                selectionEnd: 5,
                passwordSelectionStart: 2,
                passwordSelectionEnd: 2,
              },
              output: {
                value: "🇺🇸",
                maskedValue: "-🇺🇸 -",
                passwordMaskedValue: "-• -",
                selectionStart: 1,
                selectionEnd: 1,
              },
            },
          ],
        },
        {
          inputTypes: ["deleteContentForward"],
          baseInput: {
            maskPattern: "-_-_-_-",
            value: "1234",
            selectionStart: 0,
            selectionEnd: 0,
          },
          variants: [
            {
              description: "unmasked to masked: delete single character",
              input: {},
              output: {
                value: "234",
                maskedValue: "-2-3-4-",
                passwordMaskedValue: "-•-•-•-",
                selectionStart: 1,
                selectionEnd: 1,
              },
            },
            {
              description: "noop: caret at end of input",
              input: {
                selectionStart: 4,
                selectionEnd: 4,
              },
              output: {
                value: "1234",
                maskedValue: "1234",
                passwordMaskedValue: "••••",
                selectionStart: 4,
                selectionEnd: 4,
              },
            },
            {
              description: "delete single character, caret does not move",
              input: {
                value: "12345",
                selectionStart: 4,
                selectionEnd: 4,
              },
              output: {
                value: "1234",
                maskedValue: "1234",
                passwordMaskedValue: "••••",
                selectionStart: 4,
                selectionEnd: 4,
              },
            },
            {
              description:
                "delete single character, following characters move backward",
              input: {
                value: "123",
                selectionStart: 3,
                selectionEnd: 3,
              },
              output: {
                value: "13",
                maskedValue: "-1-3- -",
                passwordMaskedValue: "-•-•- -",
                selectionStart: 3,
                selectionEnd: 3,
              },
            },
            {
              description:
                "delete single character, replaced with replacement character",
              input: {
                value: "123",
                selectionStart: 3,
                selectionEnd: 3,
                attributes: {
                  "show-replacement-characters": true,
                },
              },
              output: {
                value: "13",
                maskedValue: "-1-3-_-",
                passwordMaskedValue: "-•-•-_-",
                selectionStart: 3,
                selectionEnd: 3,
              },
            },
            {
              description: "delete entire input (single character)",
              input: {
                value: "1",
                selectionStart: 1,
                selectionEnd: 1,
              },
              output: {
                value: "",
                maskedValue: "",
                passwordMaskedValue: "",
                selectionStart: 0,
                selectionEnd: 0,
              },
            },
            {
              description: "delete selection",
              input: {
                value: "123",
                selectionStart: 0,
                selectionEnd: 6,
              },
              output: {
                value: "",
                maskedValue: "",
                passwordMaskedValue: "",
                selectionStart: 0,
                selectionEnd: 0,
              },
            },
            {
              description: "delete partial selection",
              input: {
                value: "123",
                selectionStart: 2,
                selectionEnd: 6,
              },
              output: {
                value: "1",
                maskedValue: "-1- - -",
                passwordMaskedValue: "-•- - -",
                selectionStart: 2,
                selectionEnd: 2,
              },
            },
            {
              description:
                "delete partial selection, caret does not move from start position",
              input: {
                value: "123",
                selectionStart: 3,
                selectionEnd: 6,
              },
              output: {
                value: "1",
                maskedValue: "-1- - -",
                passwordMaskedValue: "-•- - -",
                selectionStart: 3,
                selectionEnd: 3,
              },
            },
            {
              description: "delete entire input (single character), show mask",
              input: {
                value: "1",
                selectionStart: 1,
                selectionEnd: 1,
                attributes: {
                  "show-empty-mask": "true",
                },
              },
              output: {
                value: "",
                maskedValue: "- - - -",
                passwordMaskedValue: "- - - -",
                selectionStart: 1,
                selectionEnd: 1,
              },
            },
            {
              description: "delete grapheme cluster",
              input: {
                value: "🇯🇵🇺🇸",
                maskPattern: "-__-",
                selectionStart: 5,
                selectionEnd: 5,
                passwordSelectionStart: 2,
                passwordSelectionEnd: 2,
              },
              output: {
                value: "🇯🇵",
                maskedValue: "-🇯🇵 -",
                passwordMaskedValue: "-• -",
                selectionStart: 5,
                selectionEnd: 5,
                passwordSelectionStart: 2,
                passwordSelectionEnd: 2,
              },
            },
          ],
        },
        {
          inputTypes: ["deleteWordBackward"],
          baseInput: {
            maskPattern: "-_-_-_-_-_-",
            value: "12 34",
            selectionStart: 10,
            selectionEnd: 10,
          },
          variants: [
            {
              description: "noop: delete from start",
              input: {
                selectionStart: 1,
                selectionEnd: 1,
              },
              output: {
                value: "12 34",
                maskedValue: "-1-2- -3-4-",
                passwordMaskedValue: "-•-•-•-•-•-",
                selectionStart: 1,
                selectionEnd: 1,
              },
            },
            {
              description: "delete from middle",
              input: {
                selectionStart: 6,
                selectionEnd: 6,
              },
              output: {
                value: "34",
                maskedValue: "-3-4- - - -",
                passwordMaskedValue: "-•-•- - - -",
                selectionStart: 1,
                selectionEnd: 1,
              },
            },
            {
              description: "delete from end",
              input: {},
              output: {
                value: "12 ",
                maskedValue: "-1-2- - - -",
                passwordMaskedValue: "-•-•-•- - -",
                selectionStart: 7,
                selectionEnd: 7,
              },
            },
            {
              description: "delete from middle of word",
              input: {
                selectionStart: 8,
                selectionEnd: 8,
              },
              output: {
                value: "12 4",
                maskedValue: "-1-2- -4- -",
                passwordMaskedValue: "-•-•-•-•- -",
                selectionStart: 7,
                selectionEnd: 7,
              },
            },
            {
              description: "delete entire input (one word with trailing space)",
              input: {
                value: "12 ",
                selectionStart: 6,
                selectionEnd: 6,
              },
              output: {
                value: "",
                maskedValue: "",
                passwordMaskedValue: "",
                selectionStart: 0,
                selectionEnd: 0,
              },
            },
            {
              description: "delete only word, leaving leading space",
              input: {
                value: " 234",
                maskPattern: "-_-",
                selectionStart: 4,
                selectionEnd: 4,
              },
              output: {
                value: " ",
                maskedValue: "- -",
                passwordMaskedValue: "-•-",
                selectionStart: 2,
                selectionEnd: 2,
              },
            },
            {
              description: "delete selection",
              input: {
                selectionStart: 3,
                selectionEnd: 8,
              },
              output: {
                value: "14",
                maskedValue: "-1-4- - - -",
                passwordMaskedValue: "-•-•- - - -",
                selectionStart: 3,
                selectionEnd: 3,
              },
            },
            {
              description: "delete grapheme cluster",
              input: {
                value: "は た",
                maskPattern: "-___-",
                selectionStart: 3,
                selectionEnd: 3,
              },
              output: {
                value: "た",
                maskedValue: "-た  -",
                passwordMaskedValue: "-•  -",
                selectionStart: 1,
                selectionEnd: 1,
              },
            },
          ],
        },
        {
          inputTypes: ["deleteWordForward"],
          baseInput: {
            maskPattern: "-_-_-_-_-_-",
            value: "12 34",
            selectionStart: 1,
            selectionEnd: 1,
          },
          variants: [
            {
              description: "noop: delete from end",
              input: {
                selectionStart: 10,
                selectionEnd: 10,
              },
              output: {
                value: "12 34",
                maskedValue: "-1-2- -3-4-",
                passwordMaskedValue: "-•-•-•-•-•-",
                selectionStart: 10,
                selectionEnd: 10,
              },
            },
            {
              description: "delete from middle, before space",
              input: {
                selectionStart: 4,
                selectionEnd: 4,
              },
              output: {
                value: "12",
                maskedValue: "-1-2- - - -",
                passwordMaskedValue: "-•-•- - - -",
                selectionStart: 4,
                selectionEnd: 4,
              },
            },
            {
              description: "delete from start",
              input: {},
              output: {
                value: " 34",
                maskedValue: "- -3-4- - -",
                passwordMaskedValue: "-•-•-•- - -",
                selectionStart: 1,
                selectionEnd: 1,
              },
            },
            {
              description: "delete from middle of word",
              input: {
                selectionStart: 8,
                selectionEnd: 8,
              },
              output: {
                value: "12 3",
                maskedValue: "-1-2- -3- -",
                passwordMaskedValue: "-•-•-•-•- -",
                selectionStart: 8,
                selectionEnd: 8,
              },
            },
            {
              description: "delete entire input (one word with leading space)",
              input: {
                value: " 12",
                selectionStart: 1,
                selectionEnd: 1,
              },
              output: {
                value: "",
                maskedValue: "",
                passwordMaskedValue: "",
                selectionStart: 0,
                selectionEnd: 0,
              },
            },
            {
              description: "delete only word, leaving trailing space",
              input: {
                value: "123 ",
                maskPattern: "-_-",
                selectionStart: 0,
                selectionEnd: 0,
              },
              output: {
                value: " ",
                maskedValue: "- -",
                passwordMaskedValue: "-•-",
                selectionStart: 1,
                selectionEnd: 1,
              },
            },
            {
              description: "delete selection",
              input: {
                selectionStart: 3,
                selectionEnd: 8,
              },
              output: {
                value: "14",
                maskedValue: "-1-4- - - -",
                passwordMaskedValue: "-•-•- - - -",
                selectionStart: 3,
                selectionEnd: 3,
              },
            },
            {
              description: "delete grapheme cluster",
              input: {
                value: "は た",
                maskPattern: "-___-",
                selectionStart: 2,
                selectionEnd: 2,
              },
              output: {
                value: "は",
                maskedValue: "-は  -",
                passwordMaskedValue: "-•  -",
                selectionStart: 2,
                selectionEnd: 2,
              },
            },
          ],
        },
        {
          inputTypes: ["deleteSoftLineForward", "deleteHardLineForward"],
          baseInput: {
            maskPattern: "-_-_-_-_-",
            value: "1234",
            selectionStart: 1,
            selectionEnd: 1,
          },
          variants: [
            {
              description: "delete from start",
              input: {},
              output: {
                value: "",
                maskedValue: "",
                passwordMaskedValue: "",
                selectionStart: 0,
                selectionEnd: 0,
              },
            },
            {
              description: "noop: delete from end",
              input: {
                selectionStart: 8,
                selectionEnd: 8,
              },
              output: {
                value: "1234",
                maskedValue: "-1-2-3-4-",
                passwordMaskedValue: "-•-•-•-•-",
                selectionStart: 8,
                selectionEnd: 8,
              },
            },
            {
              description: "delete from middle (at end of 1st char)",
              input: {
                selectionStart: 2,
                selectionEnd: 2,
              },
              output: {
                value: "1",
                maskedValue: "-1- - - -",
                passwordMaskedValue: "-•- - - -",
                selectionStart: 2,
                selectionEnd: 2,
              },
            },
            {
              description: "delete from middle (at start of 2nd char)",
              input: {
                selectionStart: 3,
                selectionEnd: 3,
              },
              output: {
                value: "1",
                maskedValue: "-1- - - -",
                passwordMaskedValue: "-•- - - -",
                selectionStart: 3,
                selectionEnd: 3,
              },
            },
            {
              description: "unmasked to masked: delete from middle",
              input: {
                value: "12",
                maskPattern: "-_-",
                selectionStart: 1,
                selectionEnd: 1,
              },
              output: {
                value: "1",
                maskedValue: "-1-",
                passwordMaskedValue: "-•-",
                selectionStart: 2,
                selectionEnd: 2,
              },
            },
            {
              description: "delete grapheme cluster",
              input: {
                value: "🇯🇵🇺🇸",
                maskPattern: "-__-",
                selectionStart: 5,
                selectionEnd: 5,
                passwordSelectionStart: 2,
                passwordSelectionEnd: 2,
              },
              output: {
                value: "🇯🇵",
                maskedValue: "-🇯🇵 -",
                passwordMaskedValue: "-• -",
                selectionStart: 5,
                selectionEnd: 5,
                passwordSelectionStart: 2,
                passwordSelectionEnd: 2,
              },
            },
          ],
        },
        {
          inputTypes: ["deleteSoftLineBackward", "deleteHardLineBackward"],
          baseInput: {
            maskPattern: "-_-_-_-_-",
            value: "1234",
            selectionStart: 1,
            selectionEnd: 1,
          },
          variants: [
            {
              description: "delete from end",
              input: {
                selectionStart: 8,
                selectionEnd: 8,
              },
              output: {
                value: "",
                maskedValue: "",
                passwordMaskedValue: "",
                selectionStart: 0,
                selectionEnd: 0,
              },
            },
            {
              description: "noop: caret at start",
              input: {},
              output: {
                value: "1234",
                maskedValue: "-1-2-3-4-",
                passwordMaskedValue: "-•-•-•-•-",
                selectionStart: 1,
                selectionEnd: 1,
              },
            },
            {
              description: "delete from middle (at end of 1st char)",
              input: {
                selectionStart: 2,
                selectionEnd: 2,
              },
              output: {
                value: "234",
                maskedValue: "-2-3-4- -",
                passwordMaskedValue: "-•-•-•- -",
                selectionStart: 1,
                selectionEnd: 1,
              },
            },
            {
              description: "delete from middle (at start of 2nd char)",
              input: {
                selectionStart: 3,
                selectionEnd: 3,
              },
              output: {
                value: "234",
                maskedValue: "-2-3-4- -",
                passwordMaskedValue: "-•-•-•- -",
                selectionStart: 1,
                selectionEnd: 1,
              },
            },
            {
              description: "unmasked to masked: delete from middle",
              input: {
                value: "12",
                maskPattern: "-_-",
                selectionStart: 1,
                selectionEnd: 1,
              },
              output: {
                value: "2",
                maskedValue: "-2-",
                passwordMaskedValue: "-•-",
                selectionStart: 1,
                selectionEnd: 1,
              },
            },
            {
              description: "delete grapheme cluster",
              input: {
                value: "🇯🇵🇺🇸",
                maskPattern: "-__-",
                selectionStart: 5,
                selectionEnd: 5,
                passwordSelectionStart: 2,
                passwordSelectionEnd: 2,
              },
              output: {
                value: "🇺🇸",
                maskedValue: "-🇺🇸 -",
                passwordMaskedValue: "-• -",
                selectionStart: 1,
                selectionEnd: 1,
              },
            },
          ],
        },
        {
          inputTypes: ["deleteEntireSoftLine"],
          baseInput: {
            maskPattern: "-_-_-_-_-",
            value: "1234",
            selectionStart: 1,
            selectionEnd: 1,
          },
          variants: [
            {
              description: "delete from end",
              input: {
                selectionStart: 8,
                selectionEnd: 8,
              },
              output: {
                value: "",
                maskedValue: "",
                passwordMaskedValue: "",
                selectionStart: 0,
                selectionEnd: 0,
              },
            },
            {
              description: "delete from start",
              input: {},
              output: {
                value: "",
                maskedValue: "",
                passwordMaskedValue: "",
                selectionStart: 0,
                selectionEnd: 0,
              },
            },
            {
              description: "delete from middle",
              input: {
                selectionStart: 2,
                selectionEnd: 2,
              },
              output: {
                value: "",
                maskedValue: "",
                passwordMaskedValue: "",
                selectionStart: 0,
                selectionEnd: 0,
              },
            },
            {
              description: "delete grapheme cluster",
              input: {
                value: "🇯🇵🇺🇸",
                maskPattern: "-__-",
                selectionStart: 5,
                selectionEnd: 5,
                passwordSelectionStart: 2,
                passwordSelectionEnd: 2,
              },
              output: {
                value: "",
                maskedValue: "",
                passwordMaskedValue: "",
                selectionStart: 0,
                selectionEnd: 0,
              },
            },
          ],
        },
        {
          inputTypes: [
            "insertReplacementText",
            "insertFromYank",
            "insertFromDrop",
            "insertFromPaste",
            "insertFromPasteAsQuotation",
            "insertCompositionText",
            "insertText",
          ],
          baseInput: {
            maskPattern: "-_-_-_-",
            value: "12",
            data: "3",
            selectionStart: 4,
            selectionEnd: 4,
          },
          variants: [
            {
              description: "insert at start",
              input: {
                selectionStart: 1,
                selectionEnd: 1,
              },
              output: {
                value: "312",
                maskedValue: "-3-1-2-",
                passwordMaskedValue: "-•-•-•-",
                selectionStart: 3,
                selectionEnd: 3,
              },
            },
            {
              description: "insert at end",
              input: {},
              output: {
                value: "123",
                maskedValue: "-1-2-3-",
                passwordMaskedValue: "-•-•-•-",
                selectionStart: 6,
                selectionEnd: 6,
              },
            },
            {
              description: "insert in middle (at end of 1st char)",
              input: {
                selectionStart: 2,
                selectionEnd: 2,
              },
              output: {
                value: "132",
                maskedValue: "-1-3-2-",
                passwordMaskedValue: "-•-•-•-",
                selectionStart: 4,
                selectionEnd: 4,
              },
            },
            {
              description: "insert in middle (at start of 2nd char)",
              input: {
                selectionStart: 3,
                selectionEnd: 3,
              },
              output: {
                value: "132",
                maskedValue: "-1-3-2-",
                passwordMaskedValue: "-•-•-•-",
                selectionStart: 5,
                selectionEnd: 5,
              },
            },
            {
              description: "unmasked to masked: insert into empty input",
              input: {
                value: "",
                maskPattern: "-_-_-",
                selectionStart: 0,
                selectionEnd: 0,
              },
              output: {
                value: "3",
                maskedValue: "-3- -",
                passwordMaskedValue: "-•- -",
                selectionStart: 3,
                selectionEnd: 3,
              },
            },
            {
              description:
                "masked to unmasked: insert into full input (overflow mask)",
              input: {
                value: "1",
                maskPattern: "-_-",
                selectionStart: 2,
                selectionEnd: 2,
              },
              output: {
                value: "13",
                maskedValue: "13",
                passwordMaskedValue: "••",
                selectionStart: 2,
                selectionEnd: 2,
              },
            },
            {
              description:
                "masked to unmasked: insert into full input (show overflow mask)",
              input: {
                value: "1",
                maskPattern: "-_-",
                selectionStart: 2,
                selectionEnd: 2,
                attributes: {
                  "show-overflowed-mask": true,
                },
              },
              output: {
                value: "13",
                maskedValue: "-1-3",
                passwordMaskedValue: "-•-•",
                selectionStart: 4,
                selectionEnd: 4,
              },
            },
            {
              description: "unmasked to masked: insert grapheme cluster",
              input: {
                value: "",
                data: "🇯🇵",
                maskPattern: "-_-",
                selectionStart: 0,
                selectionEnd: 0,
              },
              output: {
                value: "🇯🇵",
                maskedValue: "-🇯🇵-",
                passwordMaskedValue: "-•-",
                selectionStart: 5,
                selectionEnd: 5,
                passwordSelectionStart: 2,
                passwordSelectionEnd: 2,
              },
            },
            {
              description: "unmasked to masked: insert over selection",
              input: {
                value: "1234",
                data: "5",
                maskPattern: "-_-_-_-",
                selectionStart: 1,
                selectionEnd: 3,
              },
              output: {
                value: "154",
                maskedValue: "-1-5-4-",
                passwordMaskedValue: "-•-•-•-",
                selectionStart: 5,
                selectionEnd: 5,
              },
            },
          ],
        },
        {
          inputTypes: ["insertTranspose"],
          baseInput: {
            maskPattern: "-_-_-",
            value: "12",
          },
          variants: [
            {
              description: "noop: caret at start",
              input: {
                selectionStart: 1,
                selectionEnd: 1,
                data: "-1",
              },
              output: {
                value: "12",
                maskedValue: "-1-2-",
                passwordMaskedValue: "-•-•-",
                selectionStart: 1,
                selectionEnd: 1,
              },
            },
            {
              description:
                "transpose between two chars (at end of 1st char) separated by a mask char",
              input: {
                selectionStart: 2,
                selectionEnd: 2,
                data: "1-",
              },
              output: {
                value: "21",
                maskedValue: "-2-1-",
                passwordMaskedValue: "-•-•-",
                selectionStart: 4,
                selectionEnd: 4,
              },
            },
            {
              description:
                "transpose between two chars (at start of 2nd char) separated by a mask char",
              input: {
                selectionStart: 3,
                selectionEnd: 3,
                data: "-2",
              },
              output: {
                value: "21",
                maskedValue: "-2-1-",
                passwordMaskedValue: "-•-•-",
                selectionStart: 4,
                selectionEnd: 4,
              },
            },
            {
              description:
                "transpose between two chars (at end of 2nd char) separated by a mask char",
              input: {
                selectionStart: 4,
                selectionEnd: 4,
                data: "2-",
              },
              output: {
                value: "21",
                maskedValue: "-2-1-",
                passwordMaskedValue: "-•-•-",
                selectionStart: 4,
                selectionEnd: 4,
              },
            },
            {
              description:
                "transpose between two chars not separated by a mask char, caret in middle",
              input: {
                selectionStart: 2,
                selectionEnd: 2,
                maskPattern: "-__-",
                data: "21",
              },
              output: {
                value: "21",
                maskedValue: "-21-",
                passwordMaskedValue: "-••-",
                selectionStart: 3,
                selectionEnd: 3,
              },
            },
            {
              description:
                "transpose between two chars not separated by a mask char, caret at end",
              input: {
                selectionStart: 3,
                selectionEnd: 3,
                maskPattern: "-__-",
                data: "2-",
              },
              output: {
                value: "21",
                maskedValue: "-21-",
                passwordMaskedValue: "-••-",
                selectionStart: 3,
                selectionEnd: 3,
              },
            },
            {
              description: "transpose grapheme cluster",
              input: {
                value: "🇯🇵🇺🇸",
                data: "🇺🇸-",
                maskPattern: "-__-",
                selectionStart: 5,
                selectionEnd: 5,
                passwordSelectionStart: 2,
                passwordSelectionEnd: 2,
              },
              output: {
                value: "🇺🇸🇯🇵",
                maskedValue: "-🇺🇸🇯🇵-",
                passwordMaskedValue: "-••-",
                selectionStart: 9,
                selectionEnd: 9,
                passwordSelectionStart: 3,
                passwordSelectionEnd: 3,
              },
            },
          ],
        },
      ];

      customElements.whenDefined("masked-input").then(() => {
        const types = [
          "text",
          "url",
          "search",
          "tel",
          "email",
          "password",
          "number",
        ];
        const attributes = [
          "mask-pattern",
          "mask-replacement-character",
          "show-empty-mask",
          "show-overflowed-mask",
          "show-replacement-characters",
          "type",
          "value",
          "maxlength",
          "minlength",
          "pattern",
          "inputmode",
          "required",
          "step",
          "min",
          "max",
        ];
        const props = [
          "maskReplacementCharacter",
          "maskPattern",
          "maskedValue",
          "value",
          "valueAsNumber",
          "type",
        ];
        const methods = [
          "select",
          "setRangeText",
          "stepUp",
          "stepDown",
          "checkValidity",
          "setAttribute",
        ];
        const events = [
          "beforeinput",
          "input", // autofill, etc.
          "cut",
          "copy",
          "dragstart",
          "focus",
          "mouseup",
          "keydown",
          // 'undo',
          // 'redo',
        ];

        // configurations
        promise_test(async (t) => {
          const m1 = createMaskedInput({
            props: {
              maskPattern: "<<_>>",
              value: "",
            },
            attrs: {
              "show-empty-mask": "",
            },
          });
          t.add_cleanup(() => {
            m1.remove();
          });
          assert_equals(m1.maskedValue, "<< >>", "with props");
          const m2 = createMaskedInput({
            attrs: {
              "show-empty-mask": "",
              "mask-pattern": "<<_>>",
              value: "",
            },
          });
          t.add_cleanup(() => {
            m2.remove();
          });
          await waitOneTick();
          assert_equals(m2.maskedValue, "<< >>", "with attributes");

          const m3 = createMaskedInput({
            attrs: {
              "show-empty-mask": "",
              "show-replacement-characters": "",
              "mask-pattern": "<<_>>",
              value: "",
            },
          });
          t.add_cleanup(() => {
            m3.remove();
          });
          await waitOneTick();
          assert_equals(
            m3.maskedValue,
            "<<_>>",
            "showing replacement characters"
          );

          const m4 = createMaskedInput({
            attrs: {
              "show-empty-mask": "",
              "show-replacement-characters": "",
              "mask-replacement-character": "X",
              "mask-pattern": "<<X>>",
              value: "",
            },
          });
          t.add_cleanup(() => {
            m4.remove();
          });
          await waitOneTick();
          assert_equals(
            m4.maskedValue,
            "<<X>>",
            "showing custom (attr) replacement characters"
          );

          const m5 = createMaskedInput({
            props: {
              maskReplacementCharacter: "X",
            },
            attrs: {
              "show-empty-mask": "",
              "show-replacement-characters": "",
              "mask-pattern": "<<X>>",
              value: "",
            },
          });
          t.add_cleanup(() => {
            m5.remove();
          });
          await waitOneTick();
          assert_equals(
            m5.maskedValue,
            "<<X>>",
            "showing custom (prop) replacement characters"
          );

          const m6 = createMaskedInput({
            props: {
              maskReplacementCharacter: "X",
            },
            attrs: {
              "mask-pattern": "<<X>>",
              value: "",
            },
          });
          t.add_cleanup(() => {
            m6.remove();
          });
          await waitOneTick();
          assert_equals(m6.maskedValue, "", "defaults to empty display value");
        }, "empty masked input in various configurations");

        promise_test(async () => {
          assert_throws_dom(
            "NotSupportedError",
            () => {
              const m = createMaskedInput({ props: { type: "range" } });
              m.remove();
            },
            "invalid type (prop)"
          );
          const attrError = catchWindowError(() => {
            const m = createMaskedInput({ attrs: { type: "range" } });
            m.remove();
          });
          await waitOneTick();
          assert_equals(
            "NotSupportedError",
            attrError?.name,
            "invalid type (attr)"
          );
        }, "invalid configurations");

        promise_test(async (t) => {
          const m1 = createMaskedInput({
            props: {
              maskPattern: "<<_>>",
              value: "1",
            },
          });
          t.add_cleanup(() => {
            m1.remove();
          });
          await waitOneTick();
          assert_equals(m1.maskedValue, "<<1>>", "with props");

          const m2 = createMaskedInput({
            attrs: {
              "mask-pattern": "<<_>>",
              value: "2",
            },
          });
          t.add_cleanup(() => {
            m2.remove();
          });
          await waitOneTick();
          assert_equals(m2.maskedValue, "<<2>>", "with attributes");

          const m3 = createMaskedInput({
            attrs: {
              "show-replacement-characters": "",
              "mask-pattern": "<_> {_}",
              value: "3",
            },
          });
          t.add_cleanup(() => {
            m3.remove();
          });
          await waitOneTick();
          assert_equals(
            m3.maskedValue,
            "<3> {_}",
            "showing replacement characters"
          );

          const m4 = createMaskedInput({
            attrs: {
              "show-replacement-characters": "",
              "mask-replacement-character": "X",
              "mask-pattern": "<X> {X}",
              value: "4",
            },
          });
          t.add_cleanup(() => {
            m4.remove();
          });
          await waitOneTick();
          assert_equals(
            m4.maskedValue,
            "<4> {X}",
            "showing custom (attr) replacement characters"
          );

          const m5 = createMaskedInput({
            props: {
              maskReplacementCharacter: "X",
            },
            attrs: {
              "show-replacement-characters": "",
              "mask-pattern": "<X> {X}",
              value: "5",
            },
          });
          t.add_cleanup(() => {
            m5.remove();
          });
          await waitOneTick();
          assert_equals(
            m5.maskedValue,
            "<5> {X}",
            "showing custom (prop) replacement characters"
          );
        }, "filled masked input in various configurations");

        promise_test(async (t) => {
          const m1 = createMaskedInput({
            props: {
              maskPattern: "<<_>>",
              value: "123",
            },
          });
          t.add_cleanup(() => {
            m1.remove();
          });
          await waitOneTick();
          assert_equals(m1.maskedValue, "123", "with props");

          const m2 = createMaskedInput({
            attrs: {
              "mask-pattern": "<<_>>",
              value: "123",
            },
          });
          t.add_cleanup(() => {
            m2.remove();
          });
          await waitOneTick();
          assert_equals(m2.maskedValue, "123", "with attributes");

          const m3 = createMaskedInput({
            attrs: {
              "show-overflowed-mask": "",
              "mask-pattern": "<_> {_}",
              value: "123",
            },
          });
          t.add_cleanup(() => {
            m3.remove();
          });
          await waitOneTick();
          assert_equals(m3.maskedValue, "<1> {2}3", "showing overflowed mask");
        }, "overflowed masked input in various configurations");

        if (!/apple/i.test(navigator.vendor)) {
          // Safari doesn't support inputmode
          promise_test(async () => {
            Object.entries({
              text: "text",
              url: "url",
              search: "search",
              tel: "tel",
              email: "email",
              password: "text",
              number: "decimal",
            }).forEach(async ([type, inputmode]) => {
              const m1 = createMaskedInput({ props: { type } });
              // await waitOneTick();
              assert_equals(m1.inputMode, inputmode, `[type: ${type}]`);
              m1.remove();

              const m2 = createMaskedInput({ attrs: { type } });
              // await waitOneTick();
              assert_equals(m2.inputMode, inputmode, `[type: ${type}]`);
              m2.remove();
            });
          }, "inputmode attribute by type");
        }

        if (/apple/i.test(navigator.vendor)) {
          promise_test(async (t) => {
            const m = createMaskedInput({
              props: {
                maskPattern: "-_--_-",
                value: "12",
              },
            });
            t.add_cleanup(() => {
              m.remove();
            });
            await waitOneTick();
            m.setSelectionRange(1, 3);
            m.dispatchEvent(
              new InputEvent("beforeinput", {
                bubbles: true,
                cancelable: true,
                inputType: "insertText",
                data: "-1",
              })
            );
            await waitOneTick();
            assert_equals(m.value, "21");
            assert_equals(m.maskedValue, "-2--1-");
            assert_equals(m.selectionStart, 5);
            assert_equals(m.selectionEnd, 5);
          }, "Safari transpose event");
        }

        promise_test(async (t) => {
          const m = createMaskedInput({});
          t.add_cleanup(() => {
            m.remove();
          });
          m.addEventListener(
            "beforeinput",
            (e) => {
              e.preventDefault();
            },
            { once: true }
          );
          m.setSelectionRange(0, 0);
          m.dispatchEvent(
            new InputEvent("beforeinput", {
              inputType: "insertText",
              data: "2",
              bubbles: true,
              cancelable: true,
            })
          );
          await waitOneTick();
          assert_equals(m.value, "", "beforeinput value");
        }, "beforeinput::preventDefault()");

        promise_test(async (t) => {
          const m = createMaskedInput({});
          t.add_cleanup(() => {
            m.remove();
          });
          m.addEventListener(
            "beforeinput",
            (e) => {
              e.stopPropagation();
            },
            { once: true }
          );
          const unreachable = (e) => {
            throw new AssertionError(
              "event propagated after calling event.stopPropagation()"
            );
          };
          window.addEventListener("beforeinput", unreachable, { once: true });
          m.setSelectionRange(0, 0);
          m.dispatchEvent(
            new InputEvent("beforeinput", {
              inputType: "insertText",
              data: "2",
              bubbles: true,
              cancelable: true,
            })
          );
          await waitOneTick();
          assert_equals(m.value, "2", "beforeinput value");
          window.removeEventListener("beforeinput", unreachable, {
            once: true,
          });
        }, "beforeinput::stopPropagation()");

        promise_test(async (t) => {
          const m = createMaskedInput({});
          m.addEventListener(
            "beforeinput",
            (e) => {
              e.stopImmediatePropagation();
            },
            { once: true }
          );
          const unreachable = (e) => {
            throw new AssertionError(
              "event propagated after calling event.stopImmediatePropagation()"
            );
          };
          m.addEventListener("beforeinput", unreachable, { once: true });
          t.add_cleanup(() => {
            m.removeEventListener("beforeinput", unreachable, { once: true });
            m.remove();
          });
          m.setSelectionRange(0, 0);
          m.dispatchEvent(
            new InputEvent("beforeinput", {
              inputType: "insertText",
              data: "2",
              bubbles: true,
              cancelable: true,
            })
          );
          await waitOneTick();
          assert_equals(m.value, "2", "default still works");
        }, "beforeinput::stopImmediatePropagation()");

        promise_test(async (t) => {
          const m = createMaskedInput({});
          let stopPropagationCalled = false;
          let unreachableListenerCalled = false;
          t.add_cleanup(() => {
            m.remove();
          });
          m.addEventListener(
            "input",
            (e) => {
              e.stopPropagation();
              stopPropagationCalled = true;
            },
            { once: true }
          );
          const unreachable = (e) => {
            unreachableListenerCalled = true;
            throw new AssertionError(
              "event propagated after calling event.stopPropagation()"
            );
          };
          window.addEventListener("input", unreachable, { once: true });
          t.add_cleanup(() => {
            window.removeEventListener("input", unreachable, {
              once: true,
            });
          });
          m.setSelectionRange(0, 0);
          m.dispatchEvent(
            new InputEvent("input", {
              bubbles: true,
              cancelable: false,
            })
          );
          await waitOneTick();
          assert_true(stopPropagationCalled);
          assert_false(unreachableListenerCalled);
        }, "input::stopPropagation()");

        promise_test(async (t) => {
          const m = createMaskedInput({});
          let stopImmediatePropagationCalled = false;
          let unreachableListenerCalled = false;
          m.addEventListener(
            "input",
            (e) => {
              stopImmediatePropagationCalled = true;
              e.stopImmediatePropagation();
            },
            { once: true }
          );
          const unreachable = (e) => {
            unreachableListenerCalled = true;
            throw new AssertionError(
              "event propagated after calling event.stopImmediatePropagation()"
            );
          };
          m.addEventListener("input", unreachable, { once: true });
          t.add_cleanup(() => {
            m.removeEventListener("input", unreachable, {
              once: true,
            });
          });
          m.setSelectionRange(0, 0);
          m.dispatchEvent(
            new InputEvent("input", {
              bubbles: true,
              cancelable: false,
            })
          );
          await waitOneTick();
          assert_true(stopImmediatePropagationCalled);
          assert_false(unreachableListenerCalled);
        }, "input::stopImmediatePropagation()");

        promise_test(async (t) => {
          let windowLevelEvent;
          const m = createMaskedInput({});
          t.add_cleanup(() => {
            m.remove();
          });
          m.addEventListener(
            "cut",
            (e) => {
              e.preventDefault();
            },
            { once: true }
          );
          window.addEventListener(
            "cut",
            (e) => {
              windowLevelEvent = e;
            },
            { once: true }
          );

          m.value = "test";
          m.setSelectionRange(0, 4);

          m.dispatchEvent(
            new ClipboardEvent("cut", {
              clipboardData: new DataTransfer(),
              bubbles: true,
              cancelable: true,
            })
          );
          await waitOneTick();
          assert_equals(m.value, "test", "cut value");
          assert_equals(
            windowLevelEvent.clipboardData?.getData("text"),
            "",
            "cut clipboard"
          );
        }, "cut::preventDefault()");

        promise_test(async (t) => {
          const m = createMaskedInput({});
          let stopPropagationCalled = false;
          let unreachableListenerCalled = false;
          t.add_cleanup(() => {
            m.remove();
          });
          m.addEventListener(
            "cut",
            (e) => {
              stopPropagationCalled = true;
              e.stopPropagation();
            },
            { once: true }
          );
          const unreachable = (e) => {
            unreachableListenerCalled = true;
            throw new AssertionError(
              "event propagated after calling event.stopPropagation()"
            );
          };
          window.addEventListener("cut", unreachable, { once: true });
          t.add_cleanup(() => {
            window.removeEventListener("cut", unreachable, { once: true });
          });

          m.value = "test";
          m.setSelectionRange(0, 4);

          m.dispatchEvent(
            new ClipboardEvent("cut", {
              clipboardData: new DataTransfer(),
              bubbles: true,
              cancelable: true,
            })
          );

          await waitOneTick();
          assert_true(stopPropagationCalled);
          assert_false(unreachableListenerCalled);
          assert_equals(m.value, "", "default still works");
        }, "cut::stopPropagation()");

        promise_test(async (t) => {
          let stopImmediatePropagationCalled = false;
          let unreachableListenerCalled = false;
          const m = createMaskedInput({});
          m.addEventListener(
            "cut",
            (e) => {
              e.stopImmediatePropagation();
              stopImmediatePropagationCalled = true;
            },
            { once: true }
          );
          const unreachable = (e) => {
            unreachableListenerCalled = true;
            throw new AssertionError(
              "event propagated after calling event.stopImmediatePropagation()"
            );
          };
          m.addEventListener("cut", unreachable, { once: true });
          t.add_cleanup(() => {
            m.removeEventListener("cut", unreachable, { once: true });
            m.remove();
          });

          m.value = "test";
          m.setSelectionRange(0, 4);

          m.dispatchEvent(
            new ClipboardEvent("cut", {
              clipboardData: new DataTransfer(),
              bubbles: true,
              cancelable: true,
            })
          );

          await waitOneTick();

          assert_equals(m.value, "", "default still works");
          assert_true(stopImmediatePropagationCalled);
          assert_false(unreachableListenerCalled);
        }, "cut::stopImmediatePropagation()");

        promise_test(async (t) => {
          let windowLevelEvent;
          const m = createMaskedInput({});
          t.add_cleanup(() => {
            m.remove();
          });
          m.addEventListener(
            "copy",
            (e) => {
              e.preventDefault();
            },
            { once: true }
          );
          window.addEventListener(
            "copy",
            (e) => {
              windowLevelEvent = e;
            },
            { once: true }
          );

          m.value = "test";
          m.setSelectionRange(0, 4);

          m.dispatchEvent(
            new ClipboardEvent("copy", {
              clipboardData: new DataTransfer(),
              bubbles: true,
              cancelable: true,
            })
          );
          await waitOneTick();
          assert_equals(
            windowLevelEvent.clipboardData?.getData("text"),
            "",
            "copy clipboard"
          );
        }, "copy::preventDefault()");

        promise_test(async (t) => {
          let stopPropagationCalled = false;
          let unreachableListenerCalled = false;
          const m = createMaskedInput({});
          t.add_cleanup(() => {
            m.remove();
          });
          m.addEventListener(
            "copy",
            (e) => {
              e.stopPropagation();
              stopPropagationCalled = true;
            },
            { once: true }
          );
          const unreachable = (e) => {
            unreachableListenerCalled = true;
            throw new AssertionError(
              "event propagated after calling event.stopPropagation()"
            );
          };
          window.addEventListener("copy", unreachable, { once: true });
          t.add_cleanup(() => {
            window.removeEventListener("copy", unreachable, { once: true });
          });

          m.value = "test";
          m.setSelectionRange(0, 4);

          m.dispatchEvent(
            new ClipboardEvent("copy", {
              clipboardData: new DataTransfer(),
              bubbles: true,
              cancelable: true,
            })
          );

          await waitOneTick();

          assert_true(stopPropagationCalled);
          assert_false(unreachableListenerCalled);
        }, "copy::stopPropagation()");

        promise_test(async (t) => {
          let stopImmediatePropagationCalled = false;
          let unreachableListenerCalled = false;
          const m = createMaskedInput({});
          m.addEventListener(
            "copy",
            (e) => {
              e.stopImmediatePropagation();
              stopImmediatePropagationCalled = true;
            },
            { once: true }
          );
          const unreachable = (e) => {
            unreachableListenerCalled = true;
            throw new AssertionError(
              "event propagated after calling event.stopImmediatePropagation()"
            );
          };
          m.addEventListener("copy", unreachable, { once: true });
          t.add_cleanup(() => {
            m.removeEventListener("copy", unreachable, { once: true });
            m.remove();
          });

          m.value = "test";
          m.setSelectionRange(0, 4);

          m.dispatchEvent(
            new ClipboardEvent("copy", {
              clipboardData: new DataTransfer(),
              bubbles: true,
              cancelable: true,
            })
          );
          await waitOneTick();

          assert_true(stopImmediatePropagationCalled);
          assert_false(unreachableListenerCalled);
        }, "copy::stopImmediatePropagation()");

        promise_test(async (t) => {
          let windowLevelEvent;
          const m = createMaskedInput({});
          t.add_cleanup(() => {
            m.remove();
          });
          m.addEventListener(
            "dragstart",
            (e) => {
              e.preventDefault();
            },
            { once: true }
          );
          window.addEventListener(
            "dragstart",
            (e) => {
              windowLevelEvent = e;
            },
            { once: true }
          );
          m.value = "test";
          m.setSelectionRange(0, 4);
          m.dispatchEvent(
            new DragEvent("dragstart", {
              dataTransfer: new DataTransfer(),
              bubbles: true,
              cancelable: true,
            })
          );

          await waitOneTick();

          assert_equals(
            windowLevelEvent.dataTransfer?.getData("text"),
            "",
            "drag data"
          );
        }, "dragstart::preventDefault()");

        promise_test(async (t) => {
          let stopPropagationCalled = false;
          let unreachableListenerCalled = false;
          const m = createMaskedInput({});
          t.add_cleanup(() => {
            m.remove();
          });
          m.addEventListener(
            "dragstart",
            (e) => {
              e.stopPropagation();
              stopPropagationCalled = true;
            },
            { once: true }
          );
          const unreachable = (e) => {
            unreachableListenerCalled = true;
            throw new AssertionError(
              "event propagated after calling event.stopPropagation()"
            );
          };
          window.addEventListener("dragstart", unreachable, { once: true });
          t.add_cleanup(() => {
            window.removeEventListener("dragstart", unreachable, {
              once: true,
            });
          });

          m.value = "test";
          m.setSelectionRange(0, 4);
          m.dispatchEvent(
            new DragEvent("dragstart", {
              dataTransfer: new DataTransfer(),
              bubbles: true,
              cancelable: true,
            })
          );

          await waitOneTick();

          assert_true(stopPropagationCalled);
          assert_false(unreachableListenerCalled);
        }, "dragstart::stopPropagation()");

        promise_test(async (t) => {
          let stopImmediatePropagationCalled = false;
          let unreachableListenerCalled = false;
          const m = createMaskedInput({});
          m.addEventListener(
            "dragstart",
            (e) => {
              e.stopImmediatePropagation();
              stopImmediatePropagationCalled = true;
            },
            { once: true }
          );
          const unreachable = (e) => {
            unreachableListenerCalled = true;
            throw new AssertionError(
              "event propagated after calling event.stopImmediatePropagation()"
            );
          };
          m.addEventListener("dragstart", unreachable, { once: true });
          t.add_cleanup(() => {
            m.removeEventListener("dragstart", unreachable, { once: true });
            m.remove();
          });

          m.value = "test";
          m.setSelectionRange(0, 4);
          m.dispatchEvent(
            new DragEvent("dragstart", {
              dataTransfer: new DataTransfer(),
              bubbles: true,
              cancelable: true,
            })
          );

          await waitOneTick();

          assert_true(stopImmediatePropagationCalled);
          assert_false(unreachableListenerCalled);
        }, "dragstart::stopImmediatePropagation()");

        promise_test(async (t) => {
          const m = createMaskedInput({});
          t.add_cleanup(() => {
            m.remove();
          });
          m.addEventListener(
            "focus",
            (e) => {
              e.preventDefault();
            },
            { once: true }
          );
          m.maskPattern = "_ _ _";
          m.value = "12";
          m.setSelectionRange(5, 5);
          m.dispatchEvent(
            new FocusEvent("focus", {
              bubbles: false,
              cancelable: true,
            })
          );

          await waitOneTick();

          // focus should move the caret to the end of the masked value, 4 in this case
          assert_equals(m.selectionStart, 5, "focus selectionStart");
          assert_equals(m.selectionEnd, 5, "focus selectionEnd");
        }, "focus::preventDefault()");

        promise_test(async (t) => {
          let stopPropagationCalled = false;
          let unreachableListenerCalled = false;
          const m = createMaskedInput({});
          m.addEventListener(
            "focus",
            (e) => {
              e.stopPropagation();
              stopPropagationCalled = true;
            },
            { once: true }
          );
          const unreachable = (e) => {
            unreachableListenerCalled = true;
            throw new AssertionError(
              "event propagated after calling event.stopPropagation()"
            );
          };
          window.addEventListener("focus", unreachable, { once: true });
          t.add_cleanup(() => {
            window.removeEventListener("focus", unreachable, {
              once: true,
            });
          });

          m.maskPattern = "_ _ _";
          m.value = "12";
          m.setSelectionRange(5, 5);
          m.dispatchEvent(
            new FocusEvent("focus", {
              bubbles: false,
              cancelable: true,
            })
          );

          await waitOneTick();

          assert_equals(m.selectionStart, 4, "default still works");
          assert_true(stopPropagationCalled);
          assert_false(unreachableListenerCalled);
        }, "focus::stopPropagation()");

        promise_test(async (t) => {
          let stopImmediatePropagationCalled = false;
          let unreachableListenerCalled = false;
          const m = createMaskedInput({});
          m.addEventListener(
            "focus",
            (e) => {
              e.stopImmediatePropagation();
              stopImmediatePropagationCalled = true;
            },
            { once: true }
          );
          const unreachable = (e) => {
            unreachableListenerCalled = true;
            throw new AssertionError(
              "event propagated after calling event.stopImmediatePropagation()"
            );
          };
          m.addEventListener("focus", unreachable, { once: true });

          t.add_cleanup(() => {
            m.removeEventListener("focus", unreachable, { once: true });
            m.remove();
          });

          m.maskPattern = "_ _ _";
          m.value = "12";
          m.setSelectionRange(5, 5);
          m.dispatchEvent(
            new FocusEvent("focus", {
              bubbles: false,
              cancelable: true,
            })
          );

          await waitOneTick();

          assert_equals(m.selectionStart, 4, "default still works");
          assert_true(stopImmediatePropagationCalled);
          assert_false(unreachableListenerCalled);
        }, "focus::stopImmediatePropagation()");

        promise_test(async (t) => {
          const m = createMaskedInput({});
          t.add_cleanup(() => {
            m.remove();
          });
          m.addEventListener(
            "mouseup",
            (e) => {
              e.preventDefault();
            },
            { once: true }
          );

          m.maskPattern = "_ _ _";
          m.value = "12";
          m.setSelectionRange(5, 5);
          m.dispatchEvent(
            new MouseEvent("mouseup", {
              bubbles: true,
              cancelable: true,
            })
          );

          await waitOneTick();

          // mousedown should move the caret to the end of the masked value, 4 in this case
          assert_equals(m.selectionStart, 5, "mouseup selectionStart");
          assert_equals(m.selectionEnd, 5, "mouseup selectionEnd");
        }, "mouseup::preventDefault()");

        promise_test(async (t) => {
          let stopPropagationCalled = false;
          let unreachableListenerCalled = false;
          const m = createMaskedInput({});
          t.add_cleanup(() => {
            m.remove();
          });
          m.addEventListener(
            "mouseup",
            (e) => {
              e.stopPropagation();
              stopPropagationCalled = true;
            },
            { once: true }
          );
          const unreachable = (e) => {
            unreachableListenerCalled = true;
            throw new AssertionError(
              "event propagated after calling event.stopPropagation()"
            );
          };
          window.addEventListener("mouseup", unreachable, { once: true });
          t.add_cleanup(() => {
            window.removeEventListener("mouseup", unreachable, {
              once: true,
            });
          });

          m.maskPattern = "_ _ _";
          m.value = "12";
          m.setSelectionRange(5, 5);
          m.dispatchEvent(
            new MouseEvent("mouseup", {
              bubbles: true,
              cancelable: true,
            })
          );

          await waitOneTick();

          assert_equals(m.selectionStart, 4, "default still works");
          assert_true(stopPropagationCalled);
          assert_false(unreachableListenerCalled);
        }, "mouseup::stopPropagation()");

        promise_test(async (t) => {
          let stopImmediatePropagationCalled = false;
          let unreachableListenerCalled = false;
          const m = createMaskedInput({});
          m.addEventListener(
            "mouseup",
            (e) => {
              e.stopImmediatePropagation();
              stopImmediatePropagationCalled = true;
            },
            { once: true }
          );
          const unreachable = (e) => {
            unreachableListenerCalled = true;
            throw new AssertionError(
              "event propagated after calling event.stopImmediatePropagation()"
            );
          };
          m.addEventListener("mouseup", unreachable, { once: true });
          t.add_cleanup(() => {
            m.removeEventListener("mouseup", unreachable, { once: true });
            m.remove();
          });

          m.maskPattern = "_ _ _";
          m.value = "12";
          m.setSelectionRange(5, 5);
          m.dispatchEvent(
            new MouseEvent("mouseup", {
              bubbles: true,
              cancelable: true,
            })
          );

          await waitOneTick();

          assert_equals(m.selectionStart, 4, "default still works");
          assert_true(stopImmediatePropagationCalled);
          assert_false(unreachableListenerCalled);
        }, "mouseup::stopImmediatePropagation()");

        promise_test(async (t) => {
          const m = createMaskedInput({});
          t.add_cleanup(() => {
            m.remove();
          });
          m.addEventListener(
            "keydown",
            (e) => {
              e.preventDefault();
            },
            { once: true }
          );

          m.maskPattern = "";
          m.value = "123";
          m.setSelectionRange(2, 2);
          m.dispatchEvent(
            new KeyboardEvent("keydown", {
              key: "ArrowLeft",
              bubbles: true,
              cancelable: true,
            })
          );

          await waitOneTick();

          assert_equals(m.selectionStart, 2, "keydown selectionStart");
          assert_equals(m.selectionEnd, 2, "keydown selectionEnd");
        }, "keydown::preventDefault()");

        promise_test(async (t) => {
          let stopPropagationCalled = false;
          let unreachableListenerCalled = false;
          const m = createMaskedInput({});
          t.add_cleanup(() => {
            m.remove();
          });
          m.addEventListener(
            "keydown",
            (e) => {
              e.stopPropagation();
              stopPropagationCalled = true;
            },
            { once: true }
          );
          const unreachable = (e) => {
            unreachableListenerCalled = true;
            throw new AssertionError(
              "event propagated after calling event.stopPropagation()"
            );
          };
          window.addEventListener("keydown", unreachable, { once: true });
          t.add_cleanup(() => {
            window.removeEventListener("keydown", unreachable, {
              once: true,
            });
          });

          m.maskPattern = "";
          m.value = "123";
          m.setSelectionRange(2, 2);
          m.dispatchEvent(
            new KeyboardEvent("keydown", {
              key: "ArrowLeft",
              bubbles: true,
              cancelable: true,
            })
          );

          await waitOneTick();

          assert_equals(m.selectionStart, 1, "default still works");
          assert_true(stopPropagationCalled);
          assert_false(unreachableListenerCalled);
        }, "keydown::stopPropagation()");

        promise_test(async (t) => {
          let stopImmediatePropagationCalled = false;
          let unreachableListenerCalled = false;
          const m = createMaskedInput({});
          m.addEventListener(
            "keydown",
            (e) => {
              e.stopImmediatePropagation();
              stopImmediatePropagationCalled = true;
            },
            { once: true }
          );
          const unreachable = (e) => {
            unreachableListenerCalled = true;
            throw new AssertionError(
              "event propagated after calling event.stopImmediatePropagation()"
            );
          };
          m.addEventListener("keydown", unreachable, { once: true });
          t.add_cleanup(() => {
            m.removeEventListener("keydown", unreachable, { once: true });
            m.remove();
          });

          m.maskPattern = "";
          m.value = "123";
          m.setSelectionRange(2, 2);
          m.dispatchEvent(
            new KeyboardEvent("keydown", {
              key: "ArrowLeft",
              bubbles: true,
              cancelable: true,
            })
          );

          await waitOneTick();

          assert_equals(m.selectionStart, 1, "default still works");
          assert_true(stopImmediatePropagationCalled);
          assert_false(unreachableListenerCalled);
        }, "keydown::stopImmediatePropagation()");

        promise_test(async (t) => {
          let clipboardData;
          const logClipboardData = (event) => {
            clipboardData = event.clipboardData?.getData("text");
          };
          const m = createMaskedInput({ type: "password" });
          m.addEventListener("copy", logClipboardData, { once: true });
          t.add_cleanup(() => {
            m.removeEventListener("copy", logClipboardData, { once: true });
            m.remove();
          });

          m.value = "test";
          m.setSelectionRange(0, 4);

          m.dispatchEvent(
            new ClipboardEvent("copy", {
              clipboardData: new DataTransfer(),
              bubbles: true,
              cancelable: true,
            })
          );

          await waitOneTick();

          assert_equals(clipboardData, "");
        }, "copy should not work on password field");

        promise_test(async (t) => {
          let clipboardData;
          const logClipboardData = (event) => {
            clipboardData = event.clipboardData?.getData("text");
          };
          const m = createMaskedInput({ type: "password" });
          m.addEventListener("cut", logClipboardData, { once: true });
          t.add_cleanup(() => {
            m.removeEventListener("cut", logClipboardData, { once: true });
            m.remove();
          });

          m.value = "test";
          m.setSelectionRange(0, 4);

          m.dispatchEvent(
            new ClipboardEvent("cut", {
              clipboardData: new DataTransfer(),
              bubbles: true,
              cancelable: true,
            })
          );

          await waitOneTick();

          assert_equals(clipboardData, "");
        }, "cut should not update the clipboard on password field");

        promise_test(async (t) => {
          const m = createMaskedInput({
            props: { maskPattern: "(___) ___-____", value: "503" },
          });
          t.add_cleanup(() => {
            m.remove();
          });
          m.setSelectionRange(14, 14);
          m.dispatchEvent(
            new FocusEvent("focus", {
              bubbles: false,
              cancelable: true,
            })
          );

          await waitOneTick();

          assert_equals(m.selectionStart, 6, "selectionStart");
          assert_equals(m.selectionEnd, 6, "selectionEnd");
        }, "focus should move the caret to the end of the masked value");

        promise_test(async (t) => {
          const m = createMaskedInput({
            props: { maskPattern: "(___) ___-____", value: "503" },
          });
          t.add_cleanup(() => {
            m.remove();
          });
          m.setSelectionRange(14, 14);
          m.dispatchEvent(
            new MouseEvent("mouseup", {
              bubbles: true,
              cancelable: true,
            })
          );

          await waitOneTick();

          assert_equals(m.selectionStart, 6, "selectionStart");
          assert_equals(m.selectionEnd, 6, "selectionEnd");
        }, "mouseup should move the caret to the end of the masked value");

        promise_test(async (t) => {
          const m = createMaskedInput({
            props: { maskPattern: "(___) ___-____", value: "503" },
          });
          t.add_cleanup(() => {
            m.remove();
          });

          const left = () =>
            m.dispatchEvent(
              new KeyboardEvent("keydown", {
                key: "ArrowLeft",
                bubbles: true,
                cancelable: true,
              })
            );
          const right = () =>
            m.dispatchEvent(
              new KeyboardEvent("keydown", {
                key: "ArrowRight",
                bubbles: true,
                cancelable: true,
              })
            );
          const checkCaret = (expectedPosition, msg) => {
            assert_equals(
              m.selectionStart,
              expectedPosition,
              msg + "selectionStart"
            );
            assert_equals(
              m.selectionEnd,
              expectedPosition,
              msg + "selectionEnd"
            );
          };

          // not navigating past mask characters
          m.setSelectionRange(4, 4);
          left();
          await waitOneTick();
          checkCaret(3, "not navigating past mask characters (left)");
          right();
          await waitOneTick();
          checkCaret(4, "not navigating past mask characters (right)");

          // navigate past mask characters
          m.setSelectionRange(4, 4);
          right();
          await waitOneTick();
          checkCaret(6);
          left();
          await waitOneTick();
          checkCaret(3);

          // navigate left from beginning of mask
          m.setSelectionRange(1, 1);
          left();
          await waitOneTick();
          checkCaret(1);

          // navigate right from end of value
          m.setSelectionRange(6, 6);
          right();
          await waitOneTick();
          checkCaret(6);

          // // navigate right with whole input selected
          // m.setSelectionRange(0, 14);
          // right();
          // await waitOneTick();
          // checkCaret(6);

          // // navigate left with whole input selected
          // m.setSelectionRange(0, 14);
          // right();
          // await waitOneTick();
          // checkCaret(1);
        }, "arrow keys should navigate");

        promise_test(async (t) => {
          const m = createMaskedInput({
            props: { maskPattern: "(___) ___-____", value: "503" },
          });
          t.add_cleanup(() => {
            m.remove();
          });
          m.select();

          await waitOneTick();
          assert_equals(m.selectionStart, 0, "selectionStart");
          assert_equals(m.selectionEnd, 6, "selectionEnd");
        }, "select() should select the whole input value");

        test((t) => {
          const m1 = createMaskedInput({
            props: { maskPattern: "_-_-_", value: "123" },
          });
          t.add_cleanup(() => {
            m1.remove();
          });

          assert_throws_js(
            TypeError,
            () => {
              m1.setRangeText();
            },
            "should throw error if no arguments are passed"
          );
          m1.setRangeText("4", 0, 5);
          assert_equals(m1.value, "4");
          assert_equals(m1.maskedValue, "4- - ");
          assert_equals(m1.selectionStart, 0);
          assert_equals(m1.selectionEnd, 5);

          const m2 = createMaskedInput({
            props: { maskPattern: "_-_-_", value: "123" },
          });
          t.add_cleanup(() => {
            m2.remove();
          });
          m2.setRangeText("4", 1, 4);
          assert_equals(m2.value, "143");
          assert_equals(m2.maskedValue, "1-4-3");
          assert_equals(m2.selectionStart, 1);
          assert_equals(m2.selectionEnd, 4);

          const m3 = createMaskedInput({
            props: { maskPattern: "_-_-_-_", value: "1234" },
          });
          t.add_cleanup(() => {
            m3.remove();
          });
          m3.setRangeText("56", 1, 6, "select");
          assert_equals(m3.value, "1564");
          assert_equals(m3.maskedValue, "1-5-6-4");
          assert_equals(m3.selectionStart, 1);
          assert_equals(m3.selectionEnd, 5);

          const m4 = createMaskedInput({
            props: { maskPattern: "_-_-_-_", value: "1234" },
          });
          t.add_cleanup(() => {
            m4.remove();
          });
          m4.setRangeText("56", 1, 6, "start");
          assert_equals(m4.value, "1564");
          assert_equals(m4.maskedValue, "1-5-6-4");
          assert_equals(m4.selectionStart, 1);
          assert_equals(m4.selectionEnd, 1);

          const m5 = createMaskedInput({
            props: { maskPattern: "_-_-_-_", value: "1234" },
          });
          t.add_cleanup(() => {
            m5.remove();
          });
          m5.setRangeText("56", 1, 6, "end");
          assert_equals(m5.value, "1564");
          assert_equals(m5.maskedValue, "1-5-6-4");
          assert_equals(m5.selectionStart, 5);
          assert_equals(m5.selectionEnd, 5);

          const m6 = createMaskedInput({
            props: { maskPattern: "_-_-_-_", value: "1234" },
          });
          t.add_cleanup(() => {
            m6.remove();
          });
          m6.setSelectionRange(1, 6, "backward");
          m6.setRangeText("56");
          assert_equals(m6.value, "1564");
          assert_equals(m6.maskedValue, "1-5-6-4");
          assert_equals(m6.selectionStart, 1);
          assert_equals(m6.selectionEnd, 6);
          assert_equals(m6.selectionDirection, "backward");
        }, "setRangeText() should only replace value characters, not mask characters");

        test((t) => {
          const m = createMaskedInput({
            props: {
              type: "number",
              step: "20",
              value: "100",
              maskPattern: "_ _ _",
            },
          });
          t.add_cleanup(() => {
            m.remove();
          });
          m.stepUp();
          assert_equals(m.value, "120", "step up with no arguments: value");
          assert_equals(
            m.maskedValue,
            "1 2 0",
            "step up with no arguments: maskedValue"
          );
          m.stepDown();
          assert_equals(m.value, "100", "step down with no arguments: value");
          assert_equals(
            m.maskedValue,
            "1 0 0",
            "step down with no arguments: maskedValue"
          );
          m.stepUp(3);
          assert_equals(m.value, "160", "step up with step count: value");
          assert_equals(
            m.maskedValue,
            "1 6 0",
            "step up with step count: maskedValue"
          );
          m.stepDown(4);
          assert_equals(m.value, "80", "step down with step count: value");
          assert_equals(
            m.maskedValue,
            "8 0  ",
            "step down with step count: maskedValue"
          );
          m.value = "70";
          m.stepUp();
          assert_equals(m.value, "80", "step up from invalid number: value");
          assert_equals(
            m.maskedValue,
            "8 0  ",
            "step up from invalid number: maskedValue"
          );
          m.value = "70";
          m.stepDown();
          assert_equals(m.value, "60", "step down from invalid number: value");
          assert_equals(
            m.maskedValue,
            "6 0  ",
            "step down from invalid number: maskedalue"
          );
          m.value = "180";
          m.max = "200";
          m.stepUp(2);
          assert_equals(
            m.value,
            "200",
            "step up does not exceed max value: value"
          );
          assert_equals(
            m.maskedValue,
            "2 0 0",
            "step up does not exceed max value: maskedValue"
          );
          m.value = "40";
          m.min = "20";
          m.stepDown(2);
          assert_equals(
            m.value,
            "20",
            "step down does not fall below min value: value"
          );
          assert_equals(
            m.maskedValue,
            "2 0  ",
            "step down does not fall below min value: maskedValue"
          );
        }, "stepUp() and stepDown() work on number inputs");

        promise_test(async (t) => {
          const m = createMaskedInput({
            props: {
              type: "number",
              step: "20",
              value: "100",
              maskPattern: "_ _ _",
            },
          });
          t.add_cleanup(() => {
            m.remove();
          });
          const up = () =>
            m.dispatchEvent(
              new KeyboardEvent("keydown", {
                key: "ArrowUp",
                bubbles: true,
                cancelable: true,
              })
            );
          const down = () =>
            m.dispatchEvent(
              new KeyboardEvent("keydown", {
                key: "ArrowDown",
                bubbles: true,
                cancelable: true,
              })
            );

          m.setSelectionRange(1, 1);
          up();
          await waitOneTick();
          assert_equals(m.value, "120", "step up with no arguments: value");
          assert_equals(
            m.maskedValue,
            "1 2 0",
            "step up with no arguments: maskedValue"
          );
          assert_equals(
            m.selectionStart,
            5,
            "step up with no arguments: selectionStart"
          );

          m.setSelectionRange(1, 1);
          down();
          await waitOneTick();
          assert_equals(m.value, "100", "step down with no arguments: value");
          assert_equals(
            m.maskedValue,
            "1 0 0",
            "step down with no arguments: maskedValue"
          );
          assert_equals(
            m.selectionStart,
            5,
            "step down with no arguments: selectionStart"
          );

          m.value = "70";
          m.setSelectionRange(1, 1);
          up();
          await waitOneTick();
          assert_equals(m.value, "80", "step up from invalid number: value");
          assert_equals(
            m.maskedValue,
            "8 0  ",
            "step up from invalid number: maskedValue"
          );
          assert_equals(
            m.selectionStart,
            4,
            "step up from invalid number: selectionStart"
          );

          m.value = "70";
          m.setSelectionRange(1, 1);
          down();
          await waitOneTick();
          assert_equals(m.value, "60", "step down from invalid number: value");
          assert_equals(
            m.maskedValue,
            "6 0  ",
            "step down from invalid number: maskedValue"
          );
          assert_equals(
            m.selectionStart,
            4,
            "step down from invalid number: selectionStart"
          );

          m.value = "980";
          m.setSelectionRange(1, 1);
          up();
          await waitOneTick();
          assert_equals(m.value, "1000", "step up to unmasked display: value");
          assert_equals(
            m.maskedValue,
            "1000",
            "step up to unmasked display: maskedValue"
          );
          assert_equals(
            m.selectionStart,
            4,
            "step up to unmasked display: selectionStart"
          );
        }, "up and down arrow keys step up and down on number inputs");

        promise_test(async (t) => {
          const m1 = createMaskedInput({
            props: { value: "123", maskPattern: "🇺🇸$_🇺🇸$_🇺🇸$_" },
          });
          t.add_cleanup(() => {
            m1.remove();
          });
          assert_equals(m1.maskedValue, "🇺🇸$1🇺🇸$2🇺🇸$3");
          assert_equals(m1.maskReplacementCharacter, "_");
          m1.setAttribute("mask-replacement-character", "$");
          await waitOneTick();
          assert_equals(m1.maskedValue, "🇺🇸1_🇺🇸2_🇺🇸3_");
          assert_equals(m1.maskReplacementCharacter, "$");
          m1.maskReplacementCharacter = "🇺🇸";
          assert_equals(m1.maskedValue, "1$_2$_3$_");
          assert_equals(m1.maskReplacementCharacter, "🇺🇸");
        }, "can read and set maskReplacementCharacter");

        promise_test(async (t) => {
          const m1 = createMaskedInput({
            props: { value: "123", maskPattern: "_ _ _" },
          });
          t.add_cleanup(() => {
            m1.remove();
          });
          assert_equals(m1.maskPattern, "_ _ _");
          assert_equals(m1.maskedValue, "1 2 3");
          m1.maskPattern = "-_-_-_-";
          assert_equals(m1.maskPattern, "-_-_-_-");
          assert_equals(m1.maskedValue, "-1-2-3-");
          m1.setAttribute("mask-pattern", "**___**");
          await waitOneTick();
          assert_equals(m1.maskPattern, "**___**");
          assert_equals(m1.maskedValue, "**123**");

          const m2 = createMaskedInput({
            attrs: { value: "123", "mask-pattern": "_ _ _" },
          });
          t.add_cleanup(() => {
            m2.remove();
          });
          assert_equals(m2.maskPattern, "_ _ _");
          assert_equals(m2.maskedValue, "1 2 3");
          m2.setAttribute("mask-pattern", "**___**");
          await waitOneTick();
          assert_equals(m2.maskPattern, "**___**");
          assert_equals(m2.maskedValue, "**123**");
          m2.maskPattern = "-_-_-_-";
          assert_equals(m2.maskPattern, "-_-_-_-");
          assert_equals(m2.maskedValue, "-1-2-3-");
        }, "can read and set maskPattern");

        promise_test(async (t) => {
          const m1 = createMaskedInput({
            props: {
              type: "number",
              maskPattern: "$__.__ USD",
              value: "1234",
            },
          });
          t.add_cleanup(() => {
            m1.remove();
          });
          assert_equals(
            m1.maskedValue,
            "$12.34 USD",
            "filled pattern in number input"
          );

          const m2 = createMaskedInput({
            props: {
              type: "password",
              maskPattern: "[__ __ __]",
              value: "123456",
            },
          });
          t.add_cleanup(() => {
            m2.remove();
          });
          assert_equals(
            m2.maskedValue,
            "[•• •• ••]",
            "filled pattern in password input"
          );

          const m3 = createMaskedInput({
            props: {
              type: "number",
              maskPattern: "$__.__ USD",
              value: "12",
            },
          });
          t.add_cleanup(() => {
            m3.remove();
          });
          assert_equals(
            m3.maskedValue,
            "$12.   USD",
            "partially filled pattern in number input"
          );

          const m4 = createMaskedInput({
            props: {
              type: "password",
              maskPattern: "[__ __ __]",
              value: "1234",
            },
          });
          t.add_cleanup(() => {
            m4.remove();
          });
          assert_equals(
            m4.maskedValue,
            "[•• ••   ]",
            "partially filled pattern in password input"
          );

          const m5 = createMaskedInput({
            props: {
              type: "number",
              maskPattern: "$__.__ USD",
              value: "12",
            },
            attrs: {
              "show-replacement-characters": true,
            },
          });
          t.add_cleanup(() => {
            m5.remove();
          });
          await waitOneTick();
          assert_equals(
            m5.maskedValue,
            "$12.__ USD",
            "partially filled pattern in number input with replacement characters shown"
          );

          const m6 = createMaskedInput({
            props: {
              type: "password",
              maskPattern: "[__ __ __]",
              value: "1234",
            },
            attrs: {
              "show-replacement-characters": true,
            },
          });
          t.add_cleanup(() => {
            m6.remove();
          });
          await waitOneTick();
          assert_equals(
            m6.maskedValue,
            "[•• •• __]",
            "partially filled pattern in password input with replacement characters shown"
          );

          const m7 = createMaskedInput({
            props: {
              type: "number",
              maskPattern: "$NN.NN USD",
              maskReplacementCharacter: "N",
              value: "12",
            },
            attrs: {
              "show-replacement-characters": true,
            },
          });
          t.add_cleanup(() => {
            m7.remove();
          });
          await waitOneTick();
          assert_equals(
            m7.maskedValue,
            "$12.NN USD",
            "partially filled pattern in number input with custom replacement characters shown"
          );

          const m8 = createMaskedInput({
            props: {
              type: "password",
              maskPattern: "[NN NN NN]",
              maskReplacementCharacter: "N",
              value: "1234",
            },
            attrs: {
              "show-replacement-characters": true,
            },
          });
          t.add_cleanup(() => {
            m8.remove();
          });
          await waitOneTick();
          assert_equals(
            m8.maskedValue,
            "[•• •• NN]",
            "partially filled pattern in password input with custom replacement characters shown"
          );

          const m9 = createMaskedInput({
            props: {
              type: "number",
              maskPattern: "$__.__ USD",
              value: "",
            },
          });
          t.add_cleanup(() => {
            m9.remove();
          });
          assert_equals(m9.maskedValue, "", "empty pattern in number input");

          const m10 = createMaskedInput({
            props: {
              type: "password",
              maskPattern: "[__ __ __]",
              value: "",
            },
          });
          t.add_cleanup(() => {
            m10.remove();
          });
          assert_equals(m10.maskedValue, "", "empty pattern in password input");

          const m11 = createMaskedInput({
            props: {
              type: "number",
              maskPattern: "$__.__ USD",
              value: "",
            },
            attrs: {
              "show-empty-mask": true,
            },
          });
          t.add_cleanup(() => {
            m11.remove();
          });
          await waitOneTick();
          assert_equals(
            m11.maskedValue,
            "$  .   USD",
            "empty pattern in number input with show-empty-mask"
          );

          const m12 = createMaskedInput({
            props: {
              type: "password",
              maskPattern: "[__ __ __]",
              value: "",
            },
            attrs: {
              "show-empty-mask": true,
            },
          });
          t.add_cleanup(() => {
            m12.remove();
          });
          await waitOneTick();
          assert_equals(
            m12.maskedValue,
            "[        ]",
            "empty pattern in password input with show-empty-mask"
          );
        }, "can read maskedValue");

        test((t) => {
          const m = createMaskedInput({});
          t.add_cleanup(() => {
            m.remove();
          });
          assert_throws_dom("NotSupportedError", () => {
            m.maskedValue = "$__.__";
          });
        }, "throws error when attempting to set maskedValue");

        promise_test(async (t) => {
          const m1 = createMaskedInput({ props: { value: "123" } });
          t.add_cleanup(() => {
            m1.remove();
          });
          assert_equals(m1.value, "123");
          assert_equals(
            m1.getAttribute("value"),
            null,
            "value set as prop only is not reflected to attribute"
          );
          m1.value = "456";
          assert_equals(m1.value, "456");

          const m2 = createMaskedInput({ attrs: { value: "123" } });
          t.add_cleanup(() => {
            m2.remove();
          });
          await waitOneTick();
          assert_equals(m2.value, "123");
          assert_equals(
            m2.getAttribute("value"),
            "123",
            "value set as attribute and not yet modified by prop is reflected"
          );
          m2.setAttribute("value", "456");
          await waitOneTick();
          assert_equals(m2.value, "456");
          assert_equals(
            m2.getAttribute("value"),
            "456",
            "value set by changing attribute and not yet modified by prop is reflected"
          );
          m2.value = "789";
          assert_equals(m2.value, "789");
          assert_equals(
            m2.getAttribute("value"),
            "456",
            "value set by prop is not reflected - attribute retains previously set value"
          );
          m2.setAttribute("value", "000");
          await waitOneTick();
          assert_equals(
            m2.value,
            "789",
            "once set by prop, attribute changes do not affect the prop value"
          );
          assert_equals(
            m2.getAttribute("value"),
            "000",
            "attribute value is returned by getAttribute('value') even though it is not the displayed value"
          );
        }, "can read and set value");

        test((t) => {
          const m1 = createMaskedInput({ props: { value: "123" } });
          t.add_cleanup(() => {
            m1.remove();
          });
          assert_true(
            Number.isNaN(m1.valueAsNumber),
            "non-numeric inputs return NaN even for values that could be parsed as numbers"
          );
          assert_throws_dom(
            "InvalidStateError",
            () => {
              m1.valueAsNumber = 123;
            },
            "setting valueAsNumber on a non-numeric input throws a DOMException"
          );

          const m2 = createMaskedInput({
            props: { type: "number", value: 123 },
          });
          t.add_cleanup(() => {
            m2.remove();
          });
          assert_equals(
            m2.valueAsNumber,
            123,
            "number inputs return their value as a number for valueAsNumber"
          );
          m2.valueAsNumber = 456;
          assert_equals(
            m2.valueAsNumber,
            456,
            "setting valueAsNumber to a number should work"
          );
          m2.valueAsNumber = 1e3;
          assert_equals(
            m2.valueAsNumber,
            1000,
            "setting valueAsNumber to a number should work"
          );
          assert_equals(
            m2.value,
            "1000",
            "setting valueAsNumber to 1e3 should display 1000"
          );
          m2.valueAsNumber = "42";
          assert_equals(
            m2.valueAsNumber,
            42,
            "setting valueAsNumber to a string that can be coerced via Number() works"
          );
          m2.valueAsNumber = "4foo2";
          assert_equals(
            m2.valueAsNumber,
            NaN,
            "strings that can be parsed as numbers but not cast via Number() convert to NaN"
          );
          assert_equals(m2.value, "", "NaN values are not displayed");
        }, "can read and set valueAsNumber for number inputs");

        for (const type of types) {
          for (const otherType of types) {
            if (otherType === type) {
              continue;
            }
            for (const otherOtherType of types) {
              if (otherOtherType === type || otherOtherType === otherType) {
                continue;
              }

              promise_test(async (t) => {
                const m1 = createMaskedInput({ props: { type } });
                t.add_cleanup(() => {
                  m1.remove();
                });
                assert_equals(m1.type, type, "type prop can be read");
                assert_equals(
                  m1.getAttribute("type"),
                  type,
                  "type prop is reflected"
                );
                m1.type = otherType;
                assert_equals(
                  m1.type,
                  otherType,
                  `type prop can be set from "${type}" to "${otherType}"`
                );
                assert_equals(
                  m1.getAttribute("type"),
                  otherType,
                  "changes to the type prop are reflected"
                );
                m1.setAttribute("type", otherOtherType);
                await waitOneTick();
                assert_equals(
                  m1.type,
                  otherOtherType,
                  `setting type attribute from "${otherType}" to "${otherOtherType}" changes prop`
                );
                assert_equals(m1.getAttribute("type"), otherOtherType);

                const m2 = createMaskedInput({ attrs: { type } });
                t.add_cleanup(() => {
                  m2.remove();
                });
                await waitOneTick();
                assert_equals(m2.type, type);
                assert_equals(m2.getAttribute("type"), type);
                m2.setAttribute("type", otherOtherType);
                await waitOneTick();
                assert_equals(m2.type, otherOtherType);
                assert_equals(m2.getAttribute("type"), otherOtherType);
                m2.type = otherType;
                assert_equals(m2.type, otherType);
                assert_equals(m2.getAttribute("type"), otherType);
              }, "can read and set type::" + type);
            }
          }
        }

        promise_test(async (t) => {
          const m = createMaskedInput({
            attrs: { maxlength: "2", value: "12", "mask-pattern": "-_-_-_-" },
          });
          t.add_cleanup(() => {
            m.remove();
          });
          m.dispatchEvent(
            new InputEvent("beforeinput", {
              bubbles: true,
              cancelable: true,
              inputType: "insertText",
              data: "3",
            })
          );
          await waitOneTick();
          assert_equals(m.value, "12");
          assert_equals(m.maskedValue, "-1-2- -");
        }, "inputs should not exceed maxlength");

        promise_test(async (t) => {
          const m1 = createMaskedInput({
            attrs: { maxlength: "2", value: "123", "mask-pattern": "-_-_-_-" },
          });
          t.add_cleanup(() => {
            m1.remove();
          });
          await waitOneTick();
          assert_equals(m1.value, "123");
          assert_equals(m1.maskedValue, "-1-2-3-");

          const m2 = createMaskedInput({
            props: { maxLength: "2", value: "123" },
            attrs: { "mask-pattern": "-_-_-_-" },
          });
          t.add_cleanup(() => {
            m2.remove();
          });
          await waitOneTick();
          assert_equals(m2.value, "123");
          assert_equals(m2.maskedValue, "-1-2-3-");
        }, "inputs can exceed maxlength when value is explicitly set");

        promise_test(async (t) => {
          const m = createMaskedInput({
            props: {
              type: "number",
              maxLength: "2",
              value: "12",
              maskPattern: "-_-_-_-",
            },
          });
          t.add_cleanup(() => {
            m.remove();
          });
          m.dispatchEvent(
            new InputEvent("beforeinput", {
              bubbles: true,
              cancelable: true,
              inputType: "insertText",
              data: "3",
            })
          );
          await waitOneTick();
          assert_equals(m.value, "123");
          assert_equals(m.maskedValue, "-1-2-3-");
        }, "number inputs should ignore maxlength");

        test(() => {}, "checkValidity() works");
        test(() => {}, "form validation works");
        test(() => {}, "mask works on RTL inputs");
        test(() => {},
        "input accepts and masks autocomplete suggestions from list");
        test(() => {}, "matches :invalid, :user-invalid, and :out-of-range");
        test(() => {}, "");
        test(() => {}, "");
        test(() => {}, "");

        // beforeinput tests
        for (const { inputTypes, baseInput, variants } of testCases) {
          for (const { input, output, description = "" } of variants) {
            for (const inputType of inputTypes) {
              if (
                new InputEvent("beforeinput", { inputType }).inputType !==
                inputType
              ) {
                continue;
              }
              for (const selectionDirection of [
                "forward",
                "backward",
                // "none",
              ]) {
                for (const type of [
                  "text",
                  "url",
                  "search",
                  "tel",
                  "email",
                  "password",
                  "number",
                ]) {
                  const {
                    maskPattern,
                    maskReplacementCharacter,
                    value,
                    attributes = {},
                    selectionStart,
                    selectionEnd,
                    passwordSelectionStart,
                    passwordSelectionEnd,
                    data = null,
                  } = { ...baseInput, ...input };

                  if (
                    type === "number" &&
                    (!/^\d*$/.test(value) || !/^\d*$/.test(output.value))
                  ) {
                    // do not test number fields that use non-numeric values
                    continue;
                  } else {
                    promise_test(async (t) => {
                      const maskedInput = createMaskedInput({
                        props: {
                          type,
                          maskPattern,
                          maskReplacementCharacter,
                          value,
                        },
                        attrs: attributes,
                      });

                      t.add_cleanup(() => {
                        maskedInput.remove();
                      });

                      let inputEventType;
                      const logEvent = (e) => {
                        inputEventType = e.inputType;
                      };
                      maskedInput.addEventListener("input", logEvent, {
                        once: true,
                      });

                      maskedInput.setSelectionRange(
                        type === "password" && passwordSelectionStart != null
                          ? passwordSelectionStart
                          : selectionStart,
                        type === "password" && passwordSelectionEnd != null
                          ? passwordSelectionEnd
                          : selectionEnd,
                        selectionDirection
                      );
                      maskedInput.dispatchEvent(
                        new InputEvent("beforeinput", {
                          inputType,
                          data,
                          bubbles: true,
                          cancelable: true,
                        })
                      );

                      await waitOneTick();

                      assert_equals(
                        type === "password"
                          ? output.passwordMaskedValue
                          : output.maskedValue,
                        maskedInput.maskedValue,
                        "masked values"
                      );
                      assert_equals(output.value, maskedInput.value, "values");
                      assert_equals(
                        type === "password" &&
                          output.passwordSelectionStart != null
                          ? output.passwordSelectionStart
                          : output.selectionStart,
                        maskedInput.selectionStart,
                        "selection start position"
                      );
                      assert_equals(
                        type === "password" &&
                          output.passwordSelectionEnd != null
                          ? output.passwordSelectionEnd
                          : output.selectionEnd,
                        maskedInput.selectionEnd,
                        "selection end position"
                      );
                      assert_equals(
                        selectionDirection,
                        maskedInput.selectionDirection,
                        "selection direction"
                      );
                      assert_equals(inputEventType, inputType, "input type");
                    }, type + ": " + inputType + ": selectionDirection: " + selectionDirection + ": " + description);
                  }
                }
              }
            }
          }
        }
      });
    </script>
  </body>
</html>
